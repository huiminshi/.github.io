{"meta":{"title":"Aviva","subtitle":"","description":"","author":"Aviva","url":"http://yoursite.com","root":"/"},"pages":[{"title":"archives","date":"2020-03-25T09:25:12.000Z","updated":"2020-03-25T09:25:12.924Z","comments":true,"path":"archives/index.html","permalink":"http://yoursite.com/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-03-25T09:23:06.000Z","updated":"2020-03-25T09:23:43.968Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2020-03-25T09:25:28.000Z","updated":"2020-03-25T09:25:28.199Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-03-25T09:25:21.000Z","updated":"2020-03-25T09:25:21.725Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JS📝 闭包","slug":"JS📝 闭包","date":"2020-03-27T10:42:57.245Z","updated":"2020-03-27T10:51:33.785Z","comments":true,"path":"2020/03/27/JS📝 闭包/","link":"","permalink":"http://yoursite.com/2020/03/27/JS%F0%9F%93%9D%20%E9%97%AD%E5%8C%85/","excerpt":"","text":"词法环境 Lexical Environment变量所有运行的 function、代码块 {...} 和整个脚本内部都有一个隐藏的关联对象——词法环境。 词法环境对象包括两部分： 环境记录（Environment Record） —— 一个存储所有局部变量作为其属性（包括一些其他信息，例如 this 的值）的对象。 对 外部词法环境 的引用，与外部代码相关联。 A “variable” is just a property of the special internal object, Environment Record. “To get or change a variable” means “to get or change a property of that object”. 一个“变量”实际上只是环境记录器的一个属性。获取或修改这个变量意味着获取或修改这个对象的属性。 词法环境仅仅是一个规范对象，不是实际存在的无法在代码中获取与操作，主要用于描述事物如何运作的对象。 栗子🌰 左侧是一个全局代码，右侧是一个词法环境对象，方格表示环境记录，outer 表示外部引用。 当脚本开始运行，词法环境预先填充了所有声明的变量。 最初，它们处于“未初始化（Uninitialized）”状态。这是一种特殊的内部状态，这意味着引擎知道变量，但是不允许在 let 之前使用它。几乎就像变量不存在一样。 然后 let phrase 定义出现了。还未被赋值，值为 undefined。从这刻起，就可以使用这个变量。 phrase 被赋予了一个值。 phrase 的值被修改。 函数声明函数也是一个变量，不同的是，只要词法环境被创建，函数声明会立即变为可用的函数，即立即被初始化，所以可以在函数定义之前就使用它。 🌰 但这不适用于函数表达式的形式，即 let say = function(name)... 这种方式于变量的情况一致。 内部与外部词法环境当一个函数被调用时，会创建一个新的词法环境用以存储这个调用的局部变量和参数。 🌰 此时有两个词法环境：内部一个（用于函数调用）和外部一个（全局）。内部词法环境引用了 outer。 当代码要访问一个变量时 —— 首先会搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，以此类推，直到全局词法环境。 如果在任何地方都找不到这个变量，那么在严格模式下会报错，在非严格模式下，为了向后兼容，则会在全局环境创建一个未赋值的变量。 返回函数🌰 此时有两个词法环境，一个全局词法环境，一个是 makeCounter() 被调用时产生的。 所有的函数都有一个内置属性 [[Environment]]，这个属性指向创建这个函数的词法环境。即 Counter.[[Environment]] 指向 {count: 0} 词法环境。 当调用 counter() 时，会为该调用创建一个新的词法环境，并且根据 counter.[[Environment]] 获取到它的外部词法环境引用。 并且在变量所在的词法环境中修改变量的值。 闭包 Closure闭包是指内部函数总是可以访问它所在的外部函数中声明的变量和参数，即使在它外部函数被返回之后。在 JS 中除 new Function 语法外的所有函数都是天生闭包。 这是因为 JavaScript 中的函数会自动通过隐藏的 [[Environment]] 属性记住它们被创建的位置，所以它们都可以访问外部变量。 垃圾回收 Garbage collection通常，函数调用完成后，会将词法环境和其中的所有变量从内存中删除。与 JavaScript 中的其他对象一样，词法环境仅在可达时才会被保留在内存中。 但是，如果某个函数在执行结束后，它的这个词法环境仍然被引用，即依旧可达，那么它依旧会存在再变量中。 🌰 12345678910function f() &#123; let value = 123; return function() &#123; alert(value); &#125;&#125;let g = f(); // g.[[Environment]] 存储了对相应 f() 调用的词法环境的引用g = null;// 此时 f() 的词法环境不再被引用，即可被垃圾回收机制回收 理论上当函数可达时，它外部的所有变量也都将存在。但实际上，JS 引擎进行了进一步的优化，JS 引擎会分析变量的使用情况，如果这个变量明显不会被使用，那么也会被移除。因此，这类变量在 V8（Chorm/Oprea） 中调试时将不可用。 📖：Variable Scope","categories":[],"tags":[]},{"title":"JS📝 遍历方法对比","slug":"JS📝 遍历方法对比","date":"2020-03-25T13:47:50.719Z","updated":"2020-03-27T10:00:38.802Z","comments":true,"path":"2020/03/25/JS📝 遍历方法对比/","link":"","permalink":"http://yoursite.com/2020/03/25/JS%F0%9F%93%9D%20%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94/","excerpt":"","text":"遍历方法包括：for，for...in, for...of，forEach。 for...in 是用于遍历一个对象中所有可枚举的属性或索引，包括继承的属性，可以被用于数组，字符串和普通对象，不可用于 Map 和 Set 对象（因为这两个对象是可迭代对象），数组不推荐使用这个，速度会下降 10-100 倍；如果不想访问继承的属性，可改用 Object.hasOwnProperty()。 for...of 被用于遍历可迭代对象的值而不是属性/索引，实际上是在遍历具有 Symbol.iterator 属性的成员。可以被用于数组，字符串，Map 和 Set 对象，不可用于普通对象。 forEach() 则是 Array 原型中的方法，允许我们迭代数组的元素，可同时获得 value 和 index，只可用于数组。forEach 适用于循环次数未知，或者计算循环次数比较麻烦情况，不可通过 continue/break 来控制循环。forEach 的返回值总是 undefined。且不会对未初始化的值进行任何操作（稀疏数组情况）。 📖：What is the difference between JavaScript’s for…in, for…of and forEach?","categories":[],"tags":[]}]}